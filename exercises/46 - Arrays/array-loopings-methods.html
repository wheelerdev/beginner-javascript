<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>

  </title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    const toppings = ['Mushrooms ', 'Tomatoes', 'Eggs', 'Chili', 'Lettuce', 'Avocado', 'Chiles', 'Bacon', 'Pickles', 'Onions', 'Cheese'];

    function logTopping(topping, index) {
      // console.log(topping, index);
      // if index = [2] {
      index === 2
        ? console.log(topping, index)
        : null;
      // }
    }

    // toppings.forEach(logTopping);

    const students = [
      {
        id: '11ce',
        first_name: 'Dall',
        last_name: 'Puckring',
      },
      {
        id: '2958',
        first_name: 'Margarete',
        last_name: 'Brandi',
      },
      {
        id: '565a',
        first_name: 'Bendicty',
        last_name: 'Woodage',
      },
      {
        id: '3a16',
        first_name: 'Micki',
        last_name: 'Mattes',
      },
      {
        id: 'f396',
        first_name: 'Flory',
        last_name: 'Gladeche',
      },
      {
        id: 'de5f',
        first_name: 'Jamill',
        last_name: 'Emilien',
      },
      {
        id: '54cb',
        first_name: 'Brett',
        last_name: 'Aizikowitz',
      },
      {
        id: '9135',
        first_name: 'Lorry',
        last_name: 'Smallman',
      },
      {
        id: '978f',
        first_name: 'Gilly',
        last_name: 'Flott',
      },
    ];

    const people = [
      {
        birthday: 'April 22, 1993',
        names: {
          first: 'Keith',
          last: 'Buckley'
        }
      },
      {
        birthday: 'January 3, 1975',
        names: {
          first: 'Larry',
          last: 'Heep'
        }
      },
      {
        birthday: 'February 12, 1944',
        names: {
          first: 'Linda',
          last: 'Bermeer'
        }
      }
    ];

    const cleanPeople = people.map(function (person) {
      // get their birthday
      const birthday = new Date(person.birthday).getTime();
      const now = Date.now();
      // figure out age
      const age = Math.floor((now - birthday) / 31104000000);
      // console.log(age);
      // return full name and bday in an object
      return {
        age,
        name: `${person.names.first} ${person.names.last}`,
      }
    });

    // console.table(cleanPeople);

    // const over40 = cleanPeople.filter(function (person) {
    //   if (person.age > 40) {
    //     return true;
    //   } else {
    //     return false;
    //   }
    // })

    const over40 = cleanPeople.filter(person => person.age > 40);
    // console.table(over40);

    // const student = students.find(stud => stud.id === '565a');
    const student = students.find(findByProp('id', '565a'));
    const student2 = students.find(findByProp('first_name', 'Micki'));
    // console.table(student);
    // console.table(student2);

    function findByProp(prop, propWeAreLookingFor) {
      return function isStudent(student) {
        return student[prop] === propWeAreLookingFor;
      }
    }

    const buns = ['egg', 'wonder', 'brioche'];

    const meats = {
      beyond: 10,
      beef: 5,
      pork: 7
    };

    const prices = {
      hotDog: 453,
      burger: 765,
      sausage: 634,
      corn: 234,
    };

    const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];

    const faces = ['😃', '🤠', '🤡', '🤑', '😵', '🌞', '🐶', '😺'];

    const inventory = [
      { type: 'shirt', price: 4000 },
      { type: 'pants', price: 4532 },
      { type: 'socks', price: 234 },
      { type: 'shirt', price: 2343 },
      { type: 'pants', price: 2343 },
      { type: 'socks', price: 542 },
      { type: 'pants', price: 123 },
    ];

    /*
      Looping Methods
    */

    // function logTopping(topping, index, originalArray) {
    //   const nextTopping = originalArray[index + 1];
    //   const prevTopping = originalArray[index - 1];
    //   // log the topping
    //   console.log(topping);
    //   // log the prev topping if there is one
    //   prevTopping ? console.log(prevTopping) : null;

    //   // log the next topping if there is one
    //   nextTopping ? console.log(nextTopping) : null;
    //   // if its the last item in the array, say good bye
    //   index === originalArray.length - 1
    //     ? console.log('Goodbye')
    //     : console.log('Getting the next Topping');

    //   // index === originalArray.length && console.log('Goodbye');
    //   console.log('-------🍕-------');
    // }

    // toppings.forEach(logTopping);

    // // Map, Filter, Reduce
    // console.clear();

    // function addArms(face) {
    //   return `👋 ${face} 👋`;
    // }

    // const toys = faces.map(addArms);

    // console.log(toys);

    // function bosify(name) {
    //   return `${name} Bos`;
    // }

    // function capitalize(word) {
    //   return `${word[0].toUpperCase()}${word.slice(1)}`;
    // }

    // const fullNames = ['wes', 'kait', 'poppy']
    //   .map(capitalize)
    //   .map(bosify);
    // console.log(fullNames);


    // const orderTotalsWithTax = orderTotals.map(total => total * 1.13);
    // console.log(orderTotalsWithTax);

    // //     function attachBody(face, body) {
    // //       return `
    // //           ${face}
    // // 　　　　　${body.repeat(3)}
    // // 　　　　 ${Array(3).fill(body).join(' ')}
    // // 　　　👇🏽　 ${body.repeat(2)}　👇🏽
    // //         ${Array(2).fill(body).join('   ')}
    // //         ${Array(2).fill(body).join('   ')}
    // // 　　　　　👢　　👢
    // //       `
    // //     }

    // //     faces.map(face => attachBody(face, '🍟')).forEach(body => console.log(body))

    // const cleanPeople = people.map(function (person) {
    //   // timestamp
    //   const birthday = new Date(person.birthday).getTime();
    //   // now timestamp
    //   const now = Date.now();
    //   const age = Math.floor((now - birthday) / 31536000000);
    //   // get their birthday
    //   // figure out how old they are
    //   // return their full name and bday in an object
    //   return {
    //     age,
    //     name: `${person.names.first} ${person.names.last}`,
    //   }
    // });

    // console.table(cleanPeople)
    // const over40 = cleanPeople.filter(person => person.age > 40);
    // console.log(over40)

    // if (over40.length) {
    //   console.log('There are some people over 40');
    // }

    // function findById(id) {
    //   return function isStudent(student) {
    //     return student.id === id;
    //   }
    // }

    // function findByProp(prop, propWeAreLookingFor) {
    //   return function isStudent(student) {
    //     return student[prop] === propWeAreLookingFor;
    //   }
    // }

    // const student = students.find(findByProp('id', '565a'));
    // const student2 = students.find(findByProp('first_name', 'Micki'));
    // console.log(student);
    // console.log(student2);

    // // Reduce!
    // console.clear();

    // function tallyNumbers(tally, currentTotal) {
    //   console.log(`The current tally is ${tally}`);
    //   console.log(`The current total is ${currentTotal}`);
    //   console.log('---------');
    //   // return the current tally PLUS the amount of this order
    //   return tally + currentTotal;
    // }

    // const allOrders = orderTotals.reduce(tallyNumbers, 0);

    // function inventoryReducer(totals, item) {
    //   console.log(`Looping over ${item.type}`);
    //   // increment the type by 1
    //   totals[item.type] = totals[item.type] + 1 || 1;
    //   // totals.shirt ? totals.shirt + 1 : totals.shirt = 1;
    //   // return the totals, so the next loop can use it
    //   return totals;
    // }

    // const inventoryCounts = inventory.reduce(inventoryReducer, {});
    // console.log(inventoryCounts);

    // const totalInventoryPrice = inventory.reduce((acc, item) => acc + item.price, 0);
    // console.log(totalInventoryPrice);

    const text = `
    Skip to main content
Select language
Skip to search
Technologies▼
References & Guides▼
Feedback▼
Search MDN
Search MDN
Sign in
Array.prototype.map()
Web technology for developersJavaScriptJavaScript referenceStandard built-in objectsArrayArray.prototype.map()
English
▼
On this Page
Syntax
Description
Examples
Polyfill
Specifications
Browser compatibility
See also
The map() method creates a new array populated with the results of calling a provided function on every element in the calling array.


Syntax
let new_array = arr.map(function callback( currentValue[, index[, array]]) {
    // return element for new_array
}[, thisArg])
Parameters
callback
Function that is called for every element of arr. Each time callback executes, the returned value is added to new_array.

The callback function accepts the following arguments:

currentValue
The current element being processed in the array.
indexOptional
The index of the current element being processed in the array.
arrayOptional
The array map was called upon.
thisArgOptional
Value to use as this when executing callback.
Return value
A new array with each element being the result of the callback function.

Description
map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values (including undefined).

It is not called for missing elements of the array; that is:

indexes that have never been set;
which have been deleted; or
which have never been assigned a value.
When not to use map()
Since map builds a new array, using it when you aren't using the returned array is an anti-pattern; use forEach or for-of instead.

You shouldn't be using map if:

you're not using the array it returns; and/or
you're not returning a value from the callback.
Parameters in Detail
callback is invoked with three arguments: the value of the element, the index of the element, and the array object being mapped.

If a thisArg parameter is provided, it will be used as callback's this value. Otherwise, the value undefined will be used as its this value. The this value ultimately observable by callback is determined according to the usual rules for determining the this seen by a function.

map does not mutate the array on which it is called (although callback, if invoked, may do so).

The range of elements processed by map is set before the first invocation of callback. Elements which are appended to the array after the call to map begins will not be visited by callback. If existing elements of the array are changed, their value as passed to callback will be the value at the time map visits them. Elements that are deleted after the call to map begins and before being visited are not visited.

Due to the algorithm defined in the specification, if the array which map was called upon is sparse, resulting array will also be sparse keeping same indices blank.

Examples
Mapping an array of numbers to an array of square roots
The following code takes an array of numbers and creates a new array containing the square roots of the numbers in the first array.

let numbers = [1, 4, 9]
let roots = numbers.map(function(num) {
    return Math.sqrt(num)
})
// roots is now     [1, 2, 3]
// numbers is still [1, 4, 9]
Using map to reformat objects in an array
The following code takes an array of objects and creates a new array containing the newly reformatted objects.

let kvArray = [{key: 1, value: 10}, 
               {key: 2, value: 20}, 
               {key: 3, value: 30}]

let reformattedArray = kvArray.map(obj => {
   let rObj = {}
   rObj[obj.key] = obj.value
   return rObj
})
// reformattedArray is now [{1: 10}, {2: 20}, {3: 30}], 

// kvArray is still: 
// [{key: 1, value: 10}, 
//  {key: 2, value: 20}, 
//  {key: 3, value: 30}]
Mapping an array of numbers using a function containing an argument
The following code shows how map works when a function requiring one argument is used with it. The argument will automatically be assigned from each element of the array as map loops through the original array.

let numbers = [1, 4, 9]
let doubles = numbers.map(function(num) {
  return num * 2
})

// doubles is now   [2, 8, 18]
// numbers is still [1, 4, 9]
Using map generically
This example shows how to use map on a String to get an array of bytes in the ASCII encoding representing the character values:

let map = Array.prototype.map
let a = map.call('Hello World', function(x) { 
  return x.charCodeAt(0)
})
// a now equals [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
Using map generically querySelectorAll
This example shows how to iterate through a collection of objects collected by querySelectorAll. This is because querySelectorAll returns a NodeList (which is a collection of objects).

In this case, we return all the selected options' values on the screen:

let elems = document.querySelectorAll('select option:checked')
let values = Array.prototype.map.call(elems, function(obj) {
  return obj.value
})
An easier way would be the Array.from() method.

Tricky use case
(inspired by this blog post)

It is common to use the callback with one argument (the element being traversed). Certain functions are also commonly used with one argument, even though they take additional optional arguments. These habits may lead to confusing behaviors.

Consider:

["1", "2", "3"].map(parseInt)
While one might expect [1, 2, 3], the actual result is [1, NaN, NaN].

parseInt is often used with one argument, but takes two. The first is an expression and the second is the radix to the callback function, Array.prototype.map passes 3 arguments:

the element
the index
the array
The third argument is ignored by parseInt—but not the second one! This is the source of possible confusion.

Here is a concise example of the iteration steps:

// parseInt(string, radix) -> map(parseInt(value, index))
/*  first iteration  (index is 0): */ parseInt("1", 0)  // 1
/*  second iteration (index is 1): */ parseInt("2", 1)  // NaN
/*  third iteration  (index is 2): */ parseInt("3", 2)  // NaN
Then let's talk about solutions.

function returnInt(element) {
  return parseInt(element, 10)
}

['1', '2', '3'].map(returnInt); // [1, 2, 3]
// Actual result is an array of numbers (as expected)

// Same as above, but using the concise arrow function syntax
['1', '2', '3'].map( str => parseInt(str) )

// A simpler way to achieve the above, while avoiding the "gotcha":
['1', '2', '3'].map(Number)  // [1, 2, 3]

// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:
['1.1', '2.2e2', '3e300'].map(Number)  // [1.1, 220, 3e+300]

// For comparison, if we use parseInt() on the array above:
['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ) // [1, 2, 3]
One alternative output of the map method being called with parseInt as a parameter runs as follows:

let xs = ['10', '10', '10']

xs = xs.map(parseInt)

console.log(xs)
// Actual result of 10,NaN,2 may be unexpected based on the above description.
Mapped array contains undefined
When undefined or nothing is returned:

let numbers = [1, 2, 3, 4]
let filteredNumbers = numbers.map(function(num, index) {
  if (index < 3) {
     return num
  }
})
// index goes from 0, so the filterNumbers are 1,2,3 and undefined.
// filteredNumbers is [1, 2, 3, undefined]
// numbers is still [1, 2, 3, 4]

Polyfill
map was added to the ECMA-262 standard in the 5th edition. Therefore, it may not be present in all implementations of the standard.

You can work around this by inserting the following code at the beginning of your scripts, allowing use of map in implementations which do not natively support it. This algorithm is exactly the one specified in ECMA-262, 5th edition, assuming Object, TypeError, and Array have their original values and that callback.call evaluates to the original value of Function.prototype.call.

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

  Array.prototype.map = function(callback/*, thisArg*/) {

    var T, A, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this| 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal 
    //    method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let A be a new array created as if by the expression new Array(len) 
    //    where Array is the standard built-in constructor with that name and 
    //    len is the value of len.
    A = new Array(len);

    // 7. Let k be 0
    k = 0;

    // 8. Repeat, while k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal 
        //    method of O with argument Pk.
        kValue = O[k];

        // ii. Let mappedValue be the result of calling the Call internal 
        //     method of callback with T as the this value and argument 
        //     list containing kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Call the DefineOwnProperty internal method of A with arguments
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // and false.

        // In browsers that support Object.defineProperty, use the following:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // For best browser support, use the following:
        A[k] = mappedValue;
      }
      // d. Increase k by 1.
      k++;
    }

    // 9. return A
    return A;
  };
}
Specifications
Specification
ECMAScript (ECMA-262)
The definition of 'Array.prototype.map' in that specification.
Browser compatibility
Update compatibility data on GitHub
Desktop	Mobile	Server
Chrome	Edge	Firefox	Internet Explorer	Opera	Safari	Android webview	Chrome for Android	Firefox for Android	Opera for Android	Safari on iOS	Samsung Internet	Node.js
map	Full support1	Full support12	Full support1.5	Full support9	Full support9.5	Full support3	Full support≤37	Full support18	Full support4	Full support10.1	Full support1	Full support1.0	Full support0.1.100





What are we missing?
Legend
Full support 
Full support
See also
Array.prototype.forEach()
Map object
Array.from()
Metadata
Last modified: Feb 20, 2020, by MDN contributors
Related Topics
Standard built-in objects
Array
Properties
Array.length
Array.prototype[@@unscopables]
Methods
Array.from()
Array.isArray()
Array.observe()
Array.of()
Array.prototype.concat()
Array.prototype.copyWithin()
Array.prototype.entries()
Array.prototype.every()
Array.prototype.fill()
Array.prototype.filter()
Array.prototype.find()
Array.prototype.findIndex()
Array.prototype.flat()
Array.prototype.flatMap()
Array.prototype.forEach()
Array.prototype.includes()
Array.prototype.indexOf()
Array.prototype.join()
Array.prototype.keys()
Array.prototype.lastIndexOf()
Array.prototype.map()
Array.prototype.pop()
Array.prototype.push()
Array.prototype.reduce()
Array.prototype.reduceRight()
Array.prototype.reverse()
Array.prototype.shift()
Array.prototype.slice()
Array.prototype.some()
Array.prototype.sort()
Array.prototype.splice()
Array.prototype.toLocaleString()
Array.prototype.toSource()
Array.prototype.toString()
Array.prototype.unshift()
Array.prototype.values()
Array.prototype[@@iterator]()
Array.unobserve()
get Array[@@species]
Inheritance:
Function
Properties
Function.arguments
Function.arity
Function.caller
Function.displayName
Function.length
Function.name
Methods
Function.prototype.apply()
Function.prototype.bind()
Function.prototype.call()
Function.prototype.isGenerator()
Function.prototype.toSource()
Function.prototype.toString()
Object
Properties
Object.prototype.__count__
Object.prototype.__noSuchMethod__
Object.prototype.__parent__
Object.prototype.__proto__
Object.prototype.constructor
Methods
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
Object.prototype.hasOwnProperty()
Object.prototype.isPrototypeOf()
Object.prototype.propertyIsEnumerable()
Object.prototype.toLocaleString()
Object.prototype.toSource()
Object.prototype.toString()
Object.prototype.unwatch()
Object.prototype.valueOf()
Object.prototype.watch()
Object.setPrototypeOf()
Learn the best of web development
Get the latest and greatest from MDN delivered straight to your inbox.


E-mail
you@example.com
Sign up now
Hide Newsletter Sign-up
MDN Web Docs
MDN
Web Technologies
Learn Web Development
About MDN
Feedback
Mozilla
Mozilla
About
Contact Us
Firefox
TermsPrivacyCookies
© 2005-2020 Mozilla and individual contributors.Content is available under these licenses.
`;

    function isValidChar(char) {
      return char.match(/[a-z0-9]/i);
    }

    const lowerCase = char => char.toLowerCase();

    function instanceCounter(counts, char) {
      counts[char]
        ? counts[char] = counts[char] + 1
        : counts[char] = 1;

      return counts;
    }
    const everything = text
      .split('')
      .filter(isValidChar)
      .map(lowerCase)
      .reduce(instanceCounter, {});

    function sortByValue(a, b) {
      return a[1] - b[1];
    }

    const sortedResult = Object
      .entries(result)
      .sort(sortByValue);

    console.log(sortedResult);

  </script>
</body>

</html>